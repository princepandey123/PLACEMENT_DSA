//Enqueue()==>O(1)
//Dequeue()==> O(N)

struct queue{
   int front,rear,cap;
   int *arr;
   
   queue(int c)
   {
     front=rear=0;
     cap=c;
     arr=new int[cap]; 
   }
   
   void enqueue(int x)
   {
      if(isfull())
       { 
          cout<<"Queue is full";
          return ;
       }
       
      arr[rear]=x;
      rear++;
   }
   
   void Dequeue()
   {
      if(isempty())
        return;
        
      for(int i=0;i<rear-1;i++)
      {
         arr[i]=arr[i+1];
         rear--;
      }
      
    }
    
    bool isfull()
    {
        return(rear==cap);  
    }
    
    bool isempty()
    {
        return(rear==0);
    }
    
    void display()
    {
       if(front==rear)      //it is similar to isempty ()
       {
          cout<<"queue is empty ";
          return ;
       }
       
       for(int i=front;i<rear;i++)
       {
           cout<<arr[i]<<"  ";
        }
    }
    
    void getfront()
    {
        if(isempty())
        {  
           cout<<"Queue is empty"<<endl;
           return ;
        }
        
        cout<<"Front element is "<<arr[front];
    }
    
    void getrear()
    {
        if(isempty())
        {  
           cout<<"Queue is empty"<<endl;
           return ;
        }
        
        cout<<"Rear element is "<<arr[rear];
    }
    
    int main()
    {
    
    queue q(4);
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    
    q.display();
    
    q.dequeue();
    
    q.display();
    
    return 0;
    }
    
        
    ----------------------------------------------------------------------------------
    
   //Optimised Approach :-> Using Circular Array
   
   //Time Complexity :-> For All Operations, It is O(1)
   
   //In a normal Queue, we can insert elements until queue becomes full. But once queue becomes full, we can not insert the next element even if there is a space in front of queue.
   
   //Note :==> Formula to get Rear is (front+size-1)% cap;
   
   struct queue{
   int front,rear,cap;
   int *arr;
   
   queue(int c)
   {
     front=rear=-1;
     cap=c;
     arr=new int[cap]; 
   }
   
   void enqueue(int x)
   {
      if((front == 0 && rear == size-1) || (rear == (front-1)%(size-1)))                             //we can also write isfull()
       { 
          cout<<"Queue is full";
          return ;
       }
       
     else if( front==-1)             //Inserting 1st element  
      {
         front=rear=0;
         arr[rear]=x;
      }
      
      else if(rear==size-1 && front!= 0)     //Few spaces before front is empty
      {
         rear=0;
         arr[rear]=x;
      }
      
      else
      {
         rear++;
         arr[rear]=x;
       }  
   }
   
   void Dequeue()
   {
      if(front==-1)                                              //Here , we can check isempty()
      {
         cout<<"Queue is empty ";
         return;  
      }
      
      int data =arr[front];
      arr[front=-1;
      
      if(front==rear)       //When queue contains only 1 element
      {
         front=-1;
         rear=-1;
      }
      else if (front==size-1)
         front=0;
        
      else
         front++;
               
     return data;    
  }
    
    bool isfull()
    {
        return(rear==cap);  
    }
    
    bool isempty()
    {
        return(rear==0);
    }
    
    void display()
    {
       if(front==-1)      
       {
          cout<<"queue is empty ";
          return ;
       }
       
       if(rear>=front)    //Similar to normal queue
       {  
          for(int i=front;i<=rear;i++)
               cout<<arr[i]<<"   ";
       }
       else                   //when we used space before front
       {
          for(int i=front;i<size;i++)
          {  
             cout<<arr[i]<<"   ";
          }
          
          for(i=0;i<=rear;i++)
          {
              cout<<arr[i]<<"    ";
          }
          
       }  
           
    }
    
    void getfront()
    {
        if(isempty())
        {  
           cout<<"Queue is empty"<<endl;
           return ;
        }
        
        cout<<"Front element is "<<arr[front];
    }
    
    void getrear()
    {
        if(isempty())
        {  
           cout<<"Queue is empty"<<endl;
           return ;
        }
        
        cout<<"Rear element is "<<arr[rear];
    }
    
    int main()
    {
    
    queue q(4);
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    
    q.display();
    
    q.dequeue();
    
    q.display();
    
    return 0;
    }
    
        
      

//Brute Force Approach :-> Using 2 queue 

//Method 1 :-> By making Push operation costly 

/*
Steps :=>
  Enqueue
     a)Enqueue x to q2
     b) one by one dequeue every element from q1 and enqueue to q2
     c)swap the name of q1 and q2
     
  Dequeue 
     Dequeue an item from q1 and return it
     
*/

#include<bits/stdc++.h>
using namespace std;

class Stack 
{
   //Two inbuilt queue 
   queue <int>q1,q2;
   
   //To maintain no of current elements 
   int curr_size;
   
   public :
   
   Stack()
   {
      curr_size=0;
   }
   
   void push(int x)
   {
      curr_size++;
      
      //Enqueu x to empty queue q2
      
      q2.push(x);
      
      //push all elements from q1 to q2
      
      while(!q1.empty())
      {
         q2.push(q1.front());
         q1.pop();
      }
      
      //swap the names of q1 and q2
      queue<int>q=q1;
      q1=q2;
      q2=q;
   }
   
   void pop()
   {
       if(q1.empty())
          return ;
          
      q1.pop();
      curr_size--;
   }
   
   int top()
   {
      if (q1.empty())
          return -1;
      
      return q1.front();
   }
   
   int size()
   {
   return curr_size;
   }
   
 };
 
 int main()
 {
    Stack s;
    s.push(1);
    s.push(2);
    s.push(3);
    
    cout<<s.size()<<endl;
    cout<<s.top()<<endl;
    s.pop();
    cout<<s.top();
      
return 0;
}

//Method 2 :-> By making Pop operation costly 

/*
Steps :=>
  Enqueue
     Enqueue x to q1
     
  Dequeue 
   a)one by one dequeue every element  except last element from q1 and enqueue to q2
   b)Dequeue last element pf q1 , the dequeued item is the result , store it 
   c) swap the names of q1 and q2
   
*/


#include<bits/stdc++.h>
using namespace std;

class Stack 
{
   //Two inbuilt queue 
   queue <int>q1,q2;
   
   //To maintain no of current elements 
   int curr_size;
   
   public :
   
   Stack()
   {
      curr_size=0;
   }
   
   void push(int x)
   {
      q1.push(x);
      curr_size++;
   }
   
   void pop()
   {
     if(q1.empty())
         return ;
     
     //leave one element in q1 and push others to q2
     while(q1.size()!=1)
     {
        q2.push(q1.front());
        q1.pop();
     }
     
     //pop the only element left  from q1
     q1.pop();
     curr_size--;
     
     //swap the name of the queue 
     queue <int>q=q1;
     q1=q2;
     q2=q;
     
     
 }
   
   int top()
   {
      if (q1.empty())
          return -1;
    
      while(q1.size()!=1)
      { 
          q2.push(q1.front());
          q1.pop();
          
      }
      
      //last pushed element 
      
      int temp =q1.front();
      
      //To empty the auxilliary queue after last operation 
      
      q1.pop();
      
      //push last element to q2
      q2.push(temp);
      
      //swap the 2 queue name 
      queue <int>q=q1;
      q1=q2;
      q2=q;
      
      return temp;
      
   }
   
   int size()
   {
   return curr_size;
   }
   
 };
 
 int main()
 {
    Stack s;
    s.push(1);
    s.push(2);
    s.push(3);
    
    cout<<s.size()<<endl;
    cout<<s.top()<<endl;
    s.pop();
    cout<<s.top();
      
return 0;
}

// Optimise Approach  : using only 1 queue 

/*
make one queue and push the first element in it. After the first element, we push the next
element and then push the first element again and finally pop the first element

*/

#include<bits/stdc++.h>
using namespace std;

class Stack
{
   queue <int>q;
 
 public :
    void push(int data)
    {
       //Get previous size of queue 
       
       s=q.size();
       
       //push the current element 
       q.push(data);
       
       //pop all the previous element and put them after current element
       
       for(int i=0;i<s;i++)
       {
           //add the front element again 
           q.push(q.front);
           
           //delete front element
           q.pop();
           
      }
      
   }
   
   void pop()
   {
       if (q.empty())
          cout<<"No elements found"<<endl;
        
       else
          q.pop();
  }
  
  void top()
  {
     return (q.empty()) ? -1 :q.front();
  }
  
  void empty()
  {
     return (q.empty());
  }   
  
  
};

 int main()
 {
    Stack s;
    s.push(1);
    s.push(2);
    s.push(3);
    
    cout<<s.size()<<endl;
    cout<<s.top()<<endl;
    s.pop();
    cout<<s.top();
      
return 0;
}
    
        
          
       
